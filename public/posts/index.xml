<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on HackOlympus</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on HackOlympus</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Mon, 17 Jun 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lockset mechanism in linux kernel</title>
      <link>http://localhost:1313/posts/2024-06-17-lockset-mechanism-in-linux-kernel/</link>
      <pubDate>Mon, 17 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2024-06-17-lockset-mechanism-in-linux-kernel/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Lockset Mechanism in Linux kernel&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Locks:&lt;/strong&gt; Prevent multiple threads to access shared resources simultaneously by allowing only one thread to acquire “lock” at a time. When a lock is enabled for a thread, other threads are blocked from accessing the resources/memory.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Spinlocks:&lt;/strong&gt; type of lock that busy-wait until lock becomes available. Suitable when wait time is short. Should be used with precaution because takes resources while waiting and can also call deadlocks.&lt;/p&gt;</description>
    </item>
    <item>
      <title>KRACE reading notes</title>
      <link>http://localhost:1313/posts/2024-06-12-krace-reading-notes/</link>
      <pubDate>Wed, 12 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2024-06-12-krace-reading-notes/</guid>
      <description>&lt;p&gt;These are very rough notes on &lt;a href=&#34;https://ieeexplore.ieee.org/abstract/document/9152693&#34;&gt;KRACE paper&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;coverage-guided-fuzzing-in-krace&#34;&gt;Coverage guided fuzzing in KRACE&lt;/h3&gt;&#xA;&lt;p&gt;New coverage metric: alias instruction pair coverage, or alias coverage.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Branch coverage&lt;/li&gt;&#xA;&lt;li&gt;Collect all pairs of memory access instructions X &amp;lt;-&amp;gt; Y such that X may be interfering with memory being written by Y at one time.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;input-generation-in-krace&#34;&gt;Input Generation in KRACE&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Basically has the same philosophy as syzkaller. Uses a combination of syscalls and mutates on it.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Novel part:&#xA;A) multi threaded seeds (seeds are initial input to a fuzzer that is further modified) In the case of KRACE, seeds start at multiple threads.&#xA;B) KRACE preserve the the threads will interleave(combining or alternating execution of threads) in already found coverage.&#xA;C) Input generator also produce thread scheduling, it does it by employing delay injection scheme and relies on alias coverage metric to determine whether more delay is needed or not. (this scheduling cannot be employed on the whole kernel concurrency)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kernel Exploitation Notes</title>
      <link>http://localhost:1313/posts/2024-04-06-kernel-exploitation-notes/</link>
      <pubDate>Sat, 06 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2024-04-06-kernel-exploitation-notes/</guid>
      <description>&lt;h2 id=&#34;environment-setup&#34;&gt;Environment setup&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://gist.github.com/Zeus-HackOlympus/1127529039c5a45593d9a4c86570f77d&#34;&gt;Dockerfile&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;dev-files&#34;&gt;/dev files&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;/dev&lt;/code&gt; or device files represents different hardware devices attatched to the computer.&lt;/p&gt;&#xA;&lt;h4 id=&#34;types-of-device-files&#34;&gt;Types of device files&lt;/h4&gt;&#xA;&lt;p&gt;There are 2 types of device files:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Character device:&lt;/strong&gt; they read data in &lt;strong&gt;unbuffered&lt;/strong&gt; manner, one character at a time example microphone.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Block device:&lt;/strong&gt; read data in &lt;strong&gt;buffered&lt;/strong&gt; manner, one block at a time from block sizes ranging from 512 bytes, 1KB, 4KB etc.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;proc-files&#34;&gt;/proc files&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;/proc&lt;/code&gt; files contains subdirectories for each process running on the system. These direcotires contain important process specific information example &lt;code&gt;fd&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Reflections on Trusting Trust</title>
      <link>http://localhost:1313/posts/2022-08-29-reflections-on-trusting-trust/</link>
      <pubDate>Mon, 29 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2022-08-29-reflections-on-trusting-trust/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://dl.acm.org/doi/pdf/10.1145/358198.358210&#34;&gt;&lt;em&gt;Reflections on Trusting Trust&lt;/em&gt;&lt;/a&gt;, written by the legendary Sir Ken Thompson, essentially raises a deep but valid question: should we trust the code written by someone else ?&lt;/p&gt;&#xA;&lt;p&gt;The paper begins with a very interesting series of talks on various pieces of code, divided into stages and the most fascinating and overwhelming was stage 3, where Sir Ken Thompson provides us with a case study.&lt;/p&gt;&#xA;&lt;p&gt;In this case study, he tries to introduce us with an idea about how compilers can be made to have backdoors inside of them. A compiler can be designed in such a way that it injects intentionally vulnerable code into a specific program.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Memory Mapping Introduction</title>
      <link>http://localhost:1313/posts/2021-01-24-memory-mapping-introduction/</link>
      <pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2021-01-24-memory-mapping-introduction/</guid>
      <description>&lt;h4 id=&#34;memory-mapping&#34;&gt;&lt;strong&gt;Memory mapping&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;Memory of computer has addresses for its smooth working. These addresses are same for everyone and does not change from use to use. The first byte is at address 0, the second byte is at address 1, and so on until the last byte of the computer&amp;rsquo;s memory. Basically if I want to explain memory mapping in short there are memory registers that map memory. First a &amp;ldquo;logical&amp;rdquo; address is given to these processes which are currently running on the computer by CPU. This &amp;ldquo;logical&amp;rdquo; address is completely temporary and is not same for all users, its completely virtual. This process when becomes a permanent process, is assigned a &amp;ldquo;physical&amp;rdquo; address on the memory itself.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
