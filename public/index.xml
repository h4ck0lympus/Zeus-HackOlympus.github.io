<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on HackOlympus</title>
    <link>http://localhost:1313/</link>
    <description>Recent content in Home on HackOlympus</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Mon, 17 Jun 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lockset mechanism in linux kernel</title>
      <link>http://localhost:1313/posts/2024-06-17-lockset-mechanism-in-linux-kernel/</link>
      <pubDate>Mon, 17 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2024-06-17-lockset-mechanism-in-linux-kernel/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Lockset Mechanism in Linux kernel&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Locks:&lt;/strong&gt; Prevent multiple threads to access shared resources simultaneously by allowing only one thread to acquire “lock” at a time. When a lock is enabled for a thread, other threads are blocked from accessing the resources/memory.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Spinlocks:&lt;/strong&gt; type of lock that busy-wait until lock becomes available. Suitable when wait time is short. Should be used with precaution because takes resources while waiting and can also call deadlocks.&lt;/p&gt;</description>
    </item>
    <item>
      <title>KRACE reading notes</title>
      <link>http://localhost:1313/posts/2024-06-12-krace-reading-notes/</link>
      <pubDate>Wed, 12 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2024-06-12-krace-reading-notes/</guid>
      <description>&lt;p&gt;These are very rough notes on &lt;a href=&#34;https://ieeexplore.ieee.org/abstract/document/9152693&#34;&gt;KRACE paper&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;coverage-guided-fuzzing-in-krace&#34;&gt;Coverage guided fuzzing in KRACE&lt;/h3&gt;&#xA;&lt;p&gt;New coverage metric: alias instruction pair coverage, or alias coverage.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Branch coverage&lt;/li&gt;&#xA;&lt;li&gt;Collect all pairs of memory access instructions X &amp;lt;-&amp;gt; Y such that X may be interfering with memory being written by Y at one time.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;input-generation-in-krace&#34;&gt;Input Generation in KRACE&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Basically has the same philosophy as syzkaller. Uses a combination of syscalls and mutates on it.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Novel part:&#xA;A) multi threaded seeds (seeds are initial input to a fuzzer that is further modified) In the case of KRACE, seeds start at multiple threads.&#xA;B) KRACE preserve the the threads will interleave(combining or alternating execution of threads) in already found coverage.&#xA;C) Input generator also produce thread scheduling, it does it by employing delay injection scheme and relies on alias coverage metric to determine whether more delay is needed or not. (this scheduling cannot be employed on the whole kernel concurrency)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kernel Exploitation Notes</title>
      <link>http://localhost:1313/posts/2024-04-06-kernel-exploitation-notes/</link>
      <pubDate>Sat, 06 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2024-04-06-kernel-exploitation-notes/</guid>
      <description>&lt;h2 id=&#34;environment-setup&#34;&gt;Environment setup&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://gist.github.com/Zeus-HackOlympus/1127529039c5a45593d9a4c86570f77d&#34;&gt;Dockerfile&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;dev-files&#34;&gt;/dev files&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;/dev&lt;/code&gt; or device files represents different hardware devices attatched to the computer.&lt;/p&gt;&#xA;&lt;h4 id=&#34;types-of-device-files&#34;&gt;Types of device files&lt;/h4&gt;&#xA;&lt;p&gt;There are 2 types of device files:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Character device:&lt;/strong&gt; they read data in &lt;strong&gt;unbuffered&lt;/strong&gt; manner, one character at a time example microphone.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Block device:&lt;/strong&gt; read data in &lt;strong&gt;buffered&lt;/strong&gt; manner, one block at a time from block sizes ranging from 512 bytes, 1KB, 4KB etc.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;proc-files&#34;&gt;/proc files&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;/proc&lt;/code&gt; files contains subdirectories for each process running on the system. These direcotires contain important process specific information example &lt;code&gt;fd&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Reflections on Trusting Trust</title>
      <link>http://localhost:1313/posts/2022-08-29-reflections-on-trusting-trust/</link>
      <pubDate>Mon, 29 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2022-08-29-reflections-on-trusting-trust/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://dl.acm.org/doi/pdf/10.1145/358198.358210&#34;&gt;&lt;em&gt;Reflections on Trusting Trust&lt;/em&gt;&lt;/a&gt;, written by the legendary Sir Ken Thompson, essentially raises a deep but valid question: should we trust the code written by someone else ?&lt;/p&gt;&#xA;&lt;p&gt;The paper begins with a very interesting series of talks on various pieces of code, divided into stages and the most fascinating and overwhelming was stage 3, where Sir Ken Thompson provides us with a case study.&lt;/p&gt;&#xA;&lt;p&gt;In this case study, he tries to introduce us with an idea about how compilers can be made to have backdoors inside of them. A compiler can be designed in such a way that it injects intentionally vulnerable code into a specific program.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Memory Mapping Introduction</title>
      <link>http://localhost:1313/posts/2021-01-24-memory-mapping-introduction/</link>
      <pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2021-01-24-memory-mapping-introduction/</guid>
      <description>&lt;h4 id=&#34;memory-mapping&#34;&gt;&lt;strong&gt;Memory mapping&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;Memory of computer has addresses for its smooth working. These addresses are same for everyone and does not change from use to use. The first byte is at address 0, the second byte is at address 1, and so on until the last byte of the computer&amp;rsquo;s memory. Basically if I want to explain memory mapping in short there are memory registers that map memory. First a &amp;ldquo;logical&amp;rdquo; address is given to these processes which are currently running on the computer by CPU. This &amp;ldquo;logical&amp;rdquo; address is completely temporary and is not same for all users, its completely virtual. This process when becomes a permanent process, is assigned a &amp;ldquo;physical&amp;rdquo; address on the memory itself.&lt;/p&gt;</description>
    </item>
    <item>
      <title>404: Not Found</title>
      <link>http://localhost:1313/404.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/404.html</guid>
      <description>&lt;p&gt;This page cannot be found. Try to go &lt;a href=&#34;http://localhost:1313/&#34;&gt;home&lt;/a&gt; or &lt;a href=&#34;http://localhost:1313/posts/&#34;&gt;posts&lt;/a&gt; page.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Weekly progress/log</title>
      <link>http://localhost:1313/weekly-progress-log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/weekly-progress-log/</guid>
      <description>&lt;p&gt;I am planning to log my weekly progress as a way to be honest to myself and note my findings. So here it is :&lt;/p&gt;&#xA;&lt;p&gt;Before starting this, random notes from Week 0:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Why can&amp;rsquo;t we fuzz multithreaded programs using libfuzzer and afl++ ?&lt;/strong&gt; I researched and found this question answered in one of the &lt;a href=&#34;https://groups.google.com/g/afl-users/c/lzDYaClQIco&#34;&gt;google group&lt;/a&gt;.&#xA;So there are basically 2 main reasons:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;fuzzing is a feedback driven process. It uses coverage bitmap to track the coverage. More the coverage of the fuzzer the better the probability of finding bugs with the particular fuzzing instance.&#xA;This coverage bitmap is created per process so it will be shared between the threads. Whenever we fuzz multithreaded programs, we are sharing this coverage bitmap with other threads. So one of the&#xA;threads in the bitmap, marking the regions that are not covered by the other threads causing false coverage and decreasing fuzzing efficiency.&lt;/li&gt;&#xA;&lt;li&gt;another reason is the fact that AFL++ uses &lt;code&gt;fork()&lt;/code&gt; to create a replica of parent process and send input to the child input. Using &lt;code&gt;fork()&lt;/code&gt; is generally discouraged because &lt;code&gt;fork()&lt;/code&gt;&#xA;calling thread will be preserved while other threads will be killed and it can have severe impacts because locks are not released in the kernel, also shared memory can be corrupted.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;How is coverage bitmap initialized ?&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;One program contains one or more functions, each functions contain one or more basic block. These basic-blocks are basically nodes in control-flow graph (CFG). Edge between 2 nodes in CFG (i.e edge between)&#xA;is represented by one bit.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Also finally finished lvl 3. Prime trick to exploit race conditions is to keep minimum change between 2 threads running simultaneously (Atleast this worked &amp;hellip;). Before this also finished 3 papers - KRACE, razzer and exprace,&#xA;pretty interesting stuff :)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;week-1---06022024---06092024&#34;&gt;Week 1 - 06/02/2024 - 06/09/2024&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Setting up razzer. Razzer up until now is not able to compile on host &lt;code&gt;playground&lt;/code&gt; . So trying docker (I don&amp;rsquo;t want to get into dependency hell).&lt;/li&gt;&#xA;&lt;li&gt;Successful in compiling razzer. It was successful with ubuntu 16.04 with default configurations. Needed some very minor changes in create-image.sh for debootstrap to work in docker.&lt;/li&gt;&#xA;&lt;li&gt;solved lvl4. Learning &lt;strong&gt;trust GDB, IDA can be wrong, GDB cannot be&amp;hellip;&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;fork keeps the same memory layout as parent so leaking something in parent/child will be good for other sub-processes too&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;week-2---06102024---06162024&#34;&gt;Week 2 - 06/10/2024 - 06/16/2024&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;solved lvl5, lvl6, lvl7, lvl8, and lvl 12. Got Green belt.&lt;/li&gt;&#xA;&lt;li&gt;we can do &lt;code&gt;fork&lt;/code&gt; syscall using &lt;code&gt;SYS_CLONE&lt;/code&gt; with flag &lt;code&gt;SIGCHLD&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;never trusting chromium syscall blog table. &lt;code&gt;SYS_CLONE&lt;/code&gt; arguments were wrong.&lt;/li&gt;&#xA;&lt;li&gt;started afl++ reading.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;week-3---06172024---06222024&#34;&gt;Week 3 - 06/17/2024 - 06/22/2024&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;unlikely&lt;/code&gt; and &lt;code&gt;likely&lt;/code&gt; macro in afl++ source code. They help compiler to signal if a code block is usually going to be checked or not because of often same result of being true/false. Provides minor performance boost necessary in big codebase.&#xA;&lt;code&gt;long __builtin_expect(long EXP, long C);&lt;/code&gt; tells the compiler that &lt;code&gt;EXP&lt;/code&gt; will generally have value of &lt;code&gt;C&lt;/code&gt;. In almost all cases will it be used in the context of boolean expressions in which case it is much more convenient to define two helper macros:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;#define unlikely(expr) __builtin_expect(!!(expr), 0)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;#define likely(expr) __builtin_expect(!!(expr), 1)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(from &lt;a href=&#34;https://www.akkadia.org/drepper/cpumemory.pdf&#34;&gt;What every programmer should know about memory&lt;/a&gt;)&#xA;2. generate compilation database from &lt;code&gt;clang&lt;/code&gt; tooling, &lt;code&gt;bear -- &amp;lt;make command&amp;gt;&lt;/code&gt;&#xA;3. trying to test harness coverage.&#xA;4. looked into &lt;code&gt;llvm-cov&lt;/code&gt; too test coverage metric of a harness&#xA;5. GoogleCTF 2024. Worked on pycalc challenge. Learned a lot of random things about how python bytecode works. How virtual stack in cpython works. &lt;code&gt;LOAD_CONST&lt;/code&gt;, &lt;code&gt;LOAD_ATTR&lt;/code&gt; etc. JIT adaptive bytecode in python 3.11 . Studied some python optamizations in python3.11&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
